## 解决唯一索引和逻辑删除冲突的问题

1. 创建唯一索引之后，比如以code为唯一索引，code = 1的某条数据被逻辑删除之后，新增code = 1的数据会数据库报错，因为唯一索引冲突；

2. 解决办法：   

    (1). 创建条件索引

    ```sql

    ```

    (2). 对于不支持条件索引的数据库比如MySQL，利用**索引对null的字段不约束**来创建虚拟列

    ```sql
    -- 1. 添加虚拟列标识"未删除"状态
    ALTER TABLE mes_task_type 
    ADD COLUMN is_active TINYINT(1) 
    GENERATED ALWAYS AS (IF(deleted = 0, 1, NULL)) VIRTUAL COMMENT 'deleted = 0时值为1，否则NULL';

    -- 2. 创建唯一索引（仅对is_active=1生效，因为索引对null的字段不约束）
    ALTER TABLE mes_task_type 
    ADD UNIQUE INDEX uk_code_tenant_active (code, tenant_id, is_active);

    -- 3. 验证效果
    INSERT INTO mes_task_type (code, tenant_id, deleted) VALUES ('T001', 1, 0); -- 成功
    INSERT INTO mes_task_type (code, tenant_id, deleted) VALUES ('T001', 1, 0); -- 失败（Duplicate）
    UPDATE mes_task_type SET deleted = 1 WHERE code = 'T001' AND tenant_id = 1; -- 删除
    INSERT INTO mes_task_type (code, tenant_id, deleted) VALUES ('T001', 1, 0); -- 成功（原记录已删除）
    ```