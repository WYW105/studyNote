# MySQL执行计划分析 EXPLAIN命令

1. 语法 explain + select 查询语句
2. 举例

```sql
mysql> explain SELECT * FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)>1);
+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
|  1 | PRIMARY     | dept_emp | NULL       | ALL   | NULL            | NULL    | NULL    | NULL | 331143 |   100.00 | Using where |
|  2 | SUBQUERY    | dept_emp | NULL       | index | PRIMARY,dept_no | PRIMARY | 16      | NULL | 331143 |   100.00 | Using index |
+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
```
3. **explain不止支持select语句，也支持delete，insert，replace，update语句** ==> explain不会真正的执行这个语句，只是通过查询优化器分析语句。

4. explain出来的12列中每个字段的含义   

    (1). id, select标识符，用于**标志每个select语句的执行顺序**。**id值越大的最先执行，id值一样的从上往下执行**，**子查询的id值比主查询的id值大**；  

    (2). select_type, 查询类型，表明当前select是子查询、主查询还是联合查询等类型；   

    (3). table 查询的表名；   

    (4). partitions 匹配到的分区，对于未分区的表是null；   

    (5). **type** 表的访问方法所有值的顺序从最优到最差排序为：system（表中只有一行记录） > const（表中只有一行记录匹配，如用主键id查询） > eq_ref（联表查询时被驱动表中只有一行如驱动表中的对应行匹配） > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index（遍历了整个索引树） > ALL（全表扫描）   

    (6). possible_keys 可能会用到的索引；   

    (7). **key** 实际使用的索引；   

    (8). key_len 实际使用的索引长度，因为使用联合索引时，是用到的多个列的长度和==> 用到的越短越好；   

    (9). rows 估算的所需读取的行数，越小越好；   

    (10). **Extra** 其他信息

5. Extra关键字结果及性能排序：**遇到Using join buffer、Using filesort、Using temporary要优先处理，把查询推向Using index、Using index condition的情况。**

| 排名 | Extra 关键字           |描述         | 性能评价      |
| --   | ---------------------  |---------   | ---------            |
| 1    | Using index            |覆盖索引，无需回表查询 | ⭐⭐⭐⭐⭐（最佳） |
| 2    | Using index condition  |使用索引下推 | ⭐⭐⭐⭐           |
| 3    | Using where（走索引）   |Where字段使用了索引但是没用索引下推、过滤条件要在Server层完成  | ⭐⭐⭐             |
| 4    | Using where（不走索引）|Where字段没用索引需要全表扫描  | ⭐⭐                |
| 5    | Using temporary        |用了GROUP BY/ORDER BY/DISTINCT等且字段没用索引。只能用临时表存储计算过程==> 给对应字段加索引可以解决，从Using temporary变成Using index | ⭐⭐ / ⭐           |
| 6    | Using filesort         |ORDER BY字段没有索引，无法直接利用索引拿到排好序的数据 | ⭐ / ⚠️             |
| 7    | Using join buffer      |join on 字段没有索引，join时需要全表扫描、查询被驱动表中符合条件的数据 | ❌❌❌（最差）      |


